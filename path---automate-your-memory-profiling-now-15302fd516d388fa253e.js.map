{"version":3,"sources":["webpack:///path---automate-your-memory-profiling-now-15302fd516d388fa253e.js","webpack:///./.cache/json/automate-your-memory-profiling-now.json"],"names":["webpackJsonp","527","module","exports","data","site","siteMetadata","title","markdownRemark","id","html","frontmatter","date","author","bio","avatar","childImageSharp","resolutions","tracedSVG","width","height","src","srcSet","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,4BAAmCC,gBAAmBC,GAAA,yIAAAC,KAAA,igPAAqwNC,aAAsjCJ,MAAA,qCAAAK,KAAA,iBAAAC,QAA+EJ,GAAA,aAAAK,IAAA,wHAAAC,QAA0JC,iBAAmBC,aAAeC,UAAA,mnBAAAC,MAAA,GAAAC,OAAA,GAAAC,IAAA,0DAAAC,OAAA,6PAA29BC,aAAgBC,KAAA,qCAAAC,UAAwDC,QAAUF,KAAA,4DAAkEb,aAAgBJ,MAAA,6DAAoEoB,KAAA","file":"path---automate-your-memory-profiling-now-15302fd516d388fa253e.js","sourcesContent":["webpackJsonp([19834296486214],{\n\n/***/ 527:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Engineering at MindLink\"}},\"markdownRemark\":{\"id\":\"/Applications/AzureDevOpsAgent/_work/13/s/src/pages/19-04-17-automate-memory-profiling-now/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>MindLink’s core product is designed to be a long running and stable server brokering between clients and chat systems. Stability is paramount to ensure users have an optimal experience. We have a large number of automated tests, exploratory and planned manual QA processes and we dogfood our products with nightly builds.</p>\\n<p>Combined, these strategies have ensured that our products continue to be scalable, reliable and high quality. But we can do better!</p>\\n<p>Recently we discovered a memory leak late into the QA and release process and this made it out into customer hands. Not ideal, but these things happen. The leak itself has implications when lots of users log on and log out over time and will eventually cause the process to run out of memory.</p>\\n<h2>TL;DR</h2>\\n<p>By leveraging a memory profiler that provides programmatic access to snapshots you can automate memory performance testing to give you high confidence that you haven’t introduced any memory leaks into your code under reproducible scenarios.</p>\\n<p>One such profiler for .Net code that’s free (as in beer) is <a href=\\\"https://www.jetbrains.com/dotmemory/unit/\\\">dotMemory Unit</a>.</p>\\n<h2>The story</h2>\\n<p>The cause of the leak could only effectively be discovered through memory profiling and it was the result of several issues combining to cause the leak, if any one of those issues were alleviated the leak would not have occurred.</p>\\n<p>If memory profiling is what it takes to notice these, or at least some manual observation, then there is always the chance that nobody actually checks (as what happened here).</p>\\n<p>Can we do better than relying on somebody to remember to check, for every release? And to check all necessary scenarios manually? Not really…</p>\\n<h2>The search for a tool</h2>\\n<p>What we really want is a way to automate that profiling during the release pipeline and to flag memory leaks automatically.</p>\\n<p>We could crudely invoke a process snapshot before and after an operation and then compare the memory, but that isn’t going to be reliable and how do we ensure that each scenario is actually running?</p>\\n<p>Ideally we want programmatic access to a profiler so that we can:</p>\\n<ol>\\n<li>start profiling</li>\\n<li>Execute the scenario</li>\\n<li>Stop profiling</li>\\n<li>Make assertions on the profiling session</li>\\n</ol>\\n<p>As luck would have it, such magic exists! We leverage the .net framework and we are therefore fortunate to be able to benefit from the brilliant <a href=\\\"https://www.jetbrains.com/dotmemory/unit/\\\">dotMemory Unit</a> project by JetBrains (the makers of <a href=\\\"https://www.jetbrains.com/resharper/\\\">ReSharper</a> and <a href=\\\"https://kotlinlang.org/\\\">Kotlin</a>).</p>\\n<p>Unlike its GUI profiling counterpart dotMemory, dotMemory Unit is free! And it lets you programmatically profile and make assertions on the profiling session.</p>\\n<p>There are some caveats:</p>\\n<ol>\\n<li>Tests have to be synchronous</li>\\n<li>The test runner has to be called via the dotMemory Unit executable.</li>\\n</ol>\\n<p>That seems reasonable considering the power that it gives us. With dotMemory Unit we can write automated and isolated tests that ensure we don’t have memory leaks.</p>\\n<h2>Writing a memory unit test</h2>\\n<p>For our issue that snuck under the manual testing radar we knew the specific scenario that showed the issue, all we needed to do was log a user onto a chat system and then log them off again, basically the simplest scenario we could write - so that’s nice!</p>\\n<p>Here’s an example <a href=\\\"https://nunit.org/\\\">NUnit</a> test:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token punctuation\\\">[</span>Test<span class=\\\"token punctuation\\\">]</span>\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">LoggingOffCleansUpSession</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">LoggingOffCleansUpSessionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Wait</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n  dotMemory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Check</span><span class=\\\"token punctuation\\\">(</span>memory <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> Assert<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">That</span><span class=\\\"token punctuation\\\">(</span>memory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token generic-method function\\\">GetObjectsOfType<span class=\\\"token punctuation\\\">&lt;</span>ISession<span class=\\\"token punctuation\\\">></span></span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>ObjectCount<span class=\\\"token punctuation\\\">,</span> Is<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">EqualTo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">async</span> Task <span class=\\\"token function\\\">LoggingOffCleansUpSessionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> session <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">CreateSession</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n  <span class=\\\"token keyword\\\">await</span> session<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">LogOnAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n  <span class=\\\"token keyword\\\">await</span> session<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">LogOffAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>What we are doing here is creating a session, logging it on and then logging it off. Since the session is asynchronous and we want a clean test case we use an async method to perform the test steps and wait for that in the actual test to satisfy dotMemory unit’s synchronous constraint.</p>\\n<p>Our first use of dotMemory Unit was to create a test over the entire session stack, since the memory leak we encountered was the combination of internal behaviour and how the session was wired together. This high level test will also flag any memory leaks specific to individual units.</p>\\n<p>We are aiming to create memory tests for more isolated areas of our code so that we can have better coverage over different scenarios. It’s a work-in-progress, but certainly an improvement on relying on manual testing and something I think everybody should consider when stability and performance is important.</p>\\n<p>In a future post I will discuss how we integrated dotMemory Unit tests into our Azure DevOps release pipeline.</p>\",\"frontmatter\":{\"title\":\"Automate your memory profiling now\",\"date\":\"April 17, 2019\",\"author\":{\"id\":\"Luke Terry\",\"bio\":\"Senior Engineer at MindLink. Enjoys technology, playing games and making things work, blogs at www.indescrible.co.uk.\",\"avatar\":{\"childImageSharp\":{\"resolutions\":{\"tracedSVG\":\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 60 60' version='1'%3E%3Crect width='100%25' height='100%25' fill='%23f6f2f8'/%3E%3Cpath d='M0 4l1 4v17l-1 8 1 7 1 2-1 1-1 9v8h11c11 0 11 0 11-2l-2-9c0-6 0-6 2-5l5 1 4-1h-4c-4 0-8-5-11-12-2-6-3-9-1-9 4 0 5 0 4-1l-2-1c-1 1-2 0-2-2-1-4 2-9 5-10l12 1 3 1c1-1 2 2 2 3l1 5c2 4 2 4 2 2 0-3 0-3 2-1s-1 12-3 9l-1 2c0 3-5 11-7 12v1l4-3 3-4 4 4c5 6 8 13 9 18l5 1h5V34a171 171 0 0 0-1-27l1-3V0H0v4m0 12c0 3 1 4 1 2v-6c-1-1-1 0-1 4m0 17c0 4 1 6 1 3v-8l-1 5m0 21c0 4 1 5 1 3v-6c0-2-1-1-1 3' fill='%23e0d6eb' fill-rule='evenodd'/%3E%3C/svg%3E\",\"width\":60,\"height\":60,\"src\":\"/static/luke-b4696583a30eac95175e7eb6a8becde1-454f9.jpg\",\"srcSet\":\"/static/luke-b4696583a30eac95175e7eb6a8becde1-454f9.jpg 1x,\\n/static/luke-b4696583a30eac95175e7eb6a8becde1-f8c68.jpg 1.5x,\\n/static/luke-b4696583a30eac95175e7eb6a8becde1-d364e.jpg 2x,\\n/static/luke-b4696583a30eac95175e7eb6a8becde1-e5a4b.jpg 3x\"}}}}}}},\"pathContext\":{\"slug\":\"automate-your-memory-profiling-now\",\"previous\":{\"fields\":{\"slug\":\"hybrid-electron-application-deployment-in-the-enterprise\"},\"frontmatter\":{\"title\":\"Hybrid Electron application deployment in the enterprise\"}},\"next\":null}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---automate-your-memory-profiling-now-15302fd516d388fa253e.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Engineering at MindLink\"}},\"markdownRemark\":{\"id\":\"/Applications/AzureDevOpsAgent/_work/13/s/src/pages/19-04-17-automate-memory-profiling-now/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>MindLink’s core product is designed to be a long running and stable server brokering between clients and chat systems. Stability is paramount to ensure users have an optimal experience. We have a large number of automated tests, exploratory and planned manual QA processes and we dogfood our products with nightly builds.</p>\\n<p>Combined, these strategies have ensured that our products continue to be scalable, reliable and high quality. But we can do better!</p>\\n<p>Recently we discovered a memory leak late into the QA and release process and this made it out into customer hands. Not ideal, but these things happen. The leak itself has implications when lots of users log on and log out over time and will eventually cause the process to run out of memory.</p>\\n<h2>TL;DR</h2>\\n<p>By leveraging a memory profiler that provides programmatic access to snapshots you can automate memory performance testing to give you high confidence that you haven’t introduced any memory leaks into your code under reproducible scenarios.</p>\\n<p>One such profiler for .Net code that’s free (as in beer) is <a href=\\\"https://www.jetbrains.com/dotmemory/unit/\\\">dotMemory Unit</a>.</p>\\n<h2>The story</h2>\\n<p>The cause of the leak could only effectively be discovered through memory profiling and it was the result of several issues combining to cause the leak, if any one of those issues were alleviated the leak would not have occurred.</p>\\n<p>If memory profiling is what it takes to notice these, or at least some manual observation, then there is always the chance that nobody actually checks (as what happened here).</p>\\n<p>Can we do better than relying on somebody to remember to check, for every release? And to check all necessary scenarios manually? Not really…</p>\\n<h2>The search for a tool</h2>\\n<p>What we really want is a way to automate that profiling during the release pipeline and to flag memory leaks automatically.</p>\\n<p>We could crudely invoke a process snapshot before and after an operation and then compare the memory, but that isn’t going to be reliable and how do we ensure that each scenario is actually running?</p>\\n<p>Ideally we want programmatic access to a profiler so that we can:</p>\\n<ol>\\n<li>start profiling</li>\\n<li>Execute the scenario</li>\\n<li>Stop profiling</li>\\n<li>Make assertions on the profiling session</li>\\n</ol>\\n<p>As luck would have it, such magic exists! We leverage the .net framework and we are therefore fortunate to be able to benefit from the brilliant <a href=\\\"https://www.jetbrains.com/dotmemory/unit/\\\">dotMemory Unit</a> project by JetBrains (the makers of <a href=\\\"https://www.jetbrains.com/resharper/\\\">ReSharper</a> and <a href=\\\"https://kotlinlang.org/\\\">Kotlin</a>).</p>\\n<p>Unlike its GUI profiling counterpart dotMemory, dotMemory Unit is free! And it lets you programmatically profile and make assertions on the profiling session.</p>\\n<p>There are some caveats:</p>\\n<ol>\\n<li>Tests have to be synchronous</li>\\n<li>The test runner has to be called via the dotMemory Unit executable.</li>\\n</ol>\\n<p>That seems reasonable considering the power that it gives us. With dotMemory Unit we can write automated and isolated tests that ensure we don’t have memory leaks.</p>\\n<h2>Writing a memory unit test</h2>\\n<p>For our issue that snuck under the manual testing radar we knew the specific scenario that showed the issue, all we needed to do was log a user onto a chat system and then log them off again, basically the simplest scenario we could write - so that’s nice!</p>\\n<p>Here’s an example <a href=\\\"https://nunit.org/\\\">NUnit</a> test:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token punctuation\\\">[</span>Test<span class=\\\"token punctuation\\\">]</span>\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">LoggingOffCleansUpSession</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">LoggingOffCleansUpSessionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Wait</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n  dotMemory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Check</span><span class=\\\"token punctuation\\\">(</span>memory <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> Assert<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">That</span><span class=\\\"token punctuation\\\">(</span>memory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token generic-method function\\\">GetObjectsOfType<span class=\\\"token punctuation\\\">&lt;</span>ISession<span class=\\\"token punctuation\\\">></span></span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>ObjectCount<span class=\\\"token punctuation\\\">,</span> Is<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">EqualTo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">async</span> Task <span class=\\\"token function\\\">LoggingOffCleansUpSessionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> session <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">CreateSession</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n  <span class=\\\"token keyword\\\">await</span> session<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">LogOnAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n  <span class=\\\"token keyword\\\">await</span> session<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">LogOffAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>What we are doing here is creating a session, logging it on and then logging it off. Since the session is asynchronous and we want a clean test case we use an async method to perform the test steps and wait for that in the actual test to satisfy dotMemory unit’s synchronous constraint.</p>\\n<p>Our first use of dotMemory Unit was to create a test over the entire session stack, since the memory leak we encountered was the combination of internal behaviour and how the session was wired together. This high level test will also flag any memory leaks specific to individual units.</p>\\n<p>We are aiming to create memory tests for more isolated areas of our code so that we can have better coverage over different scenarios. It’s a work-in-progress, but certainly an improvement on relying on manual testing and something I think everybody should consider when stability and performance is important.</p>\\n<p>In a future post I will discuss how we integrated dotMemory Unit tests into our Azure DevOps release pipeline.</p>\",\"frontmatter\":{\"title\":\"Automate your memory profiling now\",\"date\":\"April 17, 2019\",\"author\":{\"id\":\"Luke Terry\",\"bio\":\"Senior Engineer at MindLink. Enjoys technology, playing games and making things work, blogs at www.indescrible.co.uk.\",\"avatar\":{\"childImageSharp\":{\"resolutions\":{\"tracedSVG\":\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 60 60' version='1'%3E%3Crect width='100%25' height='100%25' fill='%23f6f2f8'/%3E%3Cpath d='M0 4l1 4v17l-1 8 1 7 1 2-1 1-1 9v8h11c11 0 11 0 11-2l-2-9c0-6 0-6 2-5l5 1 4-1h-4c-4 0-8-5-11-12-2-6-3-9-1-9 4 0 5 0 4-1l-2-1c-1 1-2 0-2-2-1-4 2-9 5-10l12 1 3 1c1-1 2 2 2 3l1 5c2 4 2 4 2 2 0-3 0-3 2-1s-1 12-3 9l-1 2c0 3-5 11-7 12v1l4-3 3-4 4 4c5 6 8 13 9 18l5 1h5V34a171 171 0 0 0-1-27l1-3V0H0v4m0 12c0 3 1 4 1 2v-6c-1-1-1 0-1 4m0 17c0 4 1 6 1 3v-8l-1 5m0 21c0 4 1 5 1 3v-6c0-2-1-1-1 3' fill='%23e0d6eb' fill-rule='evenodd'/%3E%3C/svg%3E\",\"width\":60,\"height\":60,\"src\":\"/static/luke-b4696583a30eac95175e7eb6a8becde1-454f9.jpg\",\"srcSet\":\"/static/luke-b4696583a30eac95175e7eb6a8becde1-454f9.jpg 1x,\\n/static/luke-b4696583a30eac95175e7eb6a8becde1-f8c68.jpg 1.5x,\\n/static/luke-b4696583a30eac95175e7eb6a8becde1-d364e.jpg 2x,\\n/static/luke-b4696583a30eac95175e7eb6a8becde1-e5a4b.jpg 3x\"}}}}}}},\"pathContext\":{\"slug\":\"automate-your-memory-profiling-now\",\"previous\":{\"fields\":{\"slug\":\"hybrid-electron-application-deployment-in-the-enterprise\"},\"frontmatter\":{\"title\":\"Hybrid Electron application deployment in the enterprise\"}},\"next\":null}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/automate-your-memory-profiling-now.json\n// module id = 527\n// module chunks = 19834296486214"],"sourceRoot":""}