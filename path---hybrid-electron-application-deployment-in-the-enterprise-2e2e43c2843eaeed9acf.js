webpackJsonp([0x71e0ba06df11],{532:function(e,a){e.exports={data:{site:{siteMetadata:{title:"Engineering at MindLink"}},markdownRemark:{id:"/Applications/AzureDevOpsAgent/_work/13/s/src/pages/19-03-14-hybrid-electron-deployment/index.md absPath of file >>> MarkdownRemark",html:"<p>Enterprises love control, that usually means they’re only going to install your software if there’s an MSI package that they can deploy through group policy.</p>\n<p>This means that if you want a lovely auto-updating client so that you don’t have to maintain backwards compatible server code you’re <em>stuck</em>. Except there is a way forward!</p>\n<h2>TL;DR</h2>\n<p>By treating your Electron application as a browser shell and taking control of downloading the latest non-native assets from a target server (the “web app”), you can automatically sync the client version with the server version and do that securely by signing your non-native assets.</p>\n<h2>Background</h2>\n<p>It is inescapable that some form of forwards or backwards compatibility will be necessary, for MindLink we are forced to have a client that is backwards compatible with older servers since our mobile apps are app-store distributed and hence on a faster deployment cadence than the on-premise servers our customers deploy. If there’s a customer that is slow to deploy a new version, we don’t want all our other customers not getting the latest and greatest client.</p>\n<p>This means that we don’t need a backwards compatible server, and that’s brilliant because that keeps code lean and up to date.</p>\n<p>However, when we looked to package up our web app as a desktop application, suddenly we found a backwards compatible client is not enough. In an enterprise deployment often its the other way around, servers are updated first and then clients.</p>\n<p>That means we either need to also maintain a backwards compatible server, or find a way to keep clients in-sync.</p>\n<p>We know first hand the pain of keeping legacy code around for backwards compatibility - the choices available aren’t great when you’re talking about behavioural differences. Thats why we <em>really</em> want to avoid it in the server.</p>\n<h2>The modern deployment approach</h2>\n<p>Modern client deployment techniques follow an auto-update process. If you’re trying to use a really old WhatsApp then it’ll force you to install the latest update. Mobile apps and associated app stores have instilled this approach into consumers, and the same trend is happening on desktops with most services now in the cloud. Maintaining a cloud service that has to be compatible with many different client versions is an engineering overhead best avoided.</p>\n<p>The classic auto-update approach is to replace the native installation. That’s great if you’re installing into user-space, but in an Enterprise world the app is natively installed and sysadmins don’t want an automatically installed native package that they haven’t got deployment control over.</p>\n<p>You could implement a native bootloader instead, so you pull down a native payload in the bootloader and then launch that. There are security concerns around this approach and it’s possible that the native code execution is blocked by some security policy.</p>\n<p>However there is a middle ground - do exactly what a browser does. After all, Enterprises don’t stop browsers from loading web sites or apps (provided they’re not blacklisted)!</p>\n<h2>The idea</h2>\n<p>In the Electron world you’re basically a browser renderer and engine without the native interop built-in (you implement those bits yourself). So here’s the idea:</p>\n<ol>\n<li>Have a versioned native interface</li>\n<li>Load a default application payload into Chromium in an isolated context</li>\n<li>Fetch the right application payload from the server, stick it in local user app data and load that payload into the isolated context instead</li>\n<li>We can remember which payload we last used to skip always loading the default payload</li>\n</ol>\n<p>This is basically what a browser does with a cache, only we are busting the cache manually and storing the payload manually.</p>\n<p>To ensure that we aren’t getting some nefarious payload from the server we will sign the payload and verify the signature using an embedded public key in the native payload.</p>\n<p>In normal circumstances, where the server and client are the same version the default payload is used and everything is awesome.</p>\n<p>When the server is upgraded the client sees there’s a newer payload available from the server, downloads it and uses that payload instead.</p>\n<p>The same is true of a client that accesses an older server - just download the older package (although a backwards-compatible client would just work).</p>\n<p>Wait, what about the native interop?! I hear you say.</p>\n<p>Well, we can’t overwrite that native interop with the payload without opening ourselves up to other attack vectors. Instead we version the native interop and ensure that:</p>\n<ol>\n<li>Native interop maintains backwards compatibility</li>\n<li>Client maintains backwards compatibility with native interop</li>\n</ol>\n<p>Perhaps this sounds like more work than maintaining a backwards compatible server? We expect the native interop to change far less often than our server stack, and in addition all our backwards compatibility code remains client side instead of being spread between client and server.</p>\n<h2>Wrap-up</h2>\n<p>We didn’t come to this conclusion lightly, we brainstormed the approaches and overhead of maintaining a backwards compatible server and unanimously agreed that we really didn’t want to be doing that if we could avoid it. It would slow the release of new features and mean we’d have to maintain both a backwards compatible server and backwards compatible client - much nicer not to have to worry about that!</p>\n<p>This proposal is still being finalised and isn’t live yet. However, this approach essentially amounts to what a browser does, the only difference is we’re exposing some extra APIs for our “web app” to leverage.</p>",frontmatter:{title:"Hybrid Electron application deployment in the enterprise",date:"March 14, 2019",author:{id:"Luke Terry",bio:"Senior Engineer at MindLink. Enjoys technology, playing games and making things work, blogs at www.indescrible.co.uk.",avatar:{childImageSharp:{resolutions:{tracedSVG:"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 60 60' version='1'%3E%3Crect width='100%25' height='100%25' fill='%23f6f2f8'/%3E%3Cpath d='M0 4l1 4v17l-1 8 1 7 1 2-1 1-1 9v8h11c11 0 11 0 11-2l-2-9c0-6 0-6 2-5l5 1 4-1h-4c-4 0-8-5-11-12-2-6-3-9-1-9 4 0 5 0 4-1l-2-1c-1 1-2 0-2-2-1-4 2-9 5-10l12 1 3 1c1-1 2 2 2 3l1 5c2 4 2 4 2 2 0-3 0-3 2-1s-1 12-3 9l-1 2c0 3-5 11-7 12v1l4-3 3-4 4 4c5 6 8 13 9 18l5 1h5V34a171 171 0 0 0-1-27l1-3V0H0v4m0 12c0 3 1 4 1 2v-6c-1-1-1 0-1 4m0 17c0 4 1 6 1 3v-8l-1 5m0 21c0 4 1 5 1 3v-6c0-2-1-1-1 3' fill='%23e0d6eb' fill-rule='evenodd'/%3E%3C/svg%3E",width:60,height:60,src:"/static/luke-b4696583a30eac95175e7eb6a8becde1-454f9.jpg",srcSet:"/static/luke-b4696583a30eac95175e7eb6a8becde1-454f9.jpg 1x,\n/static/luke-b4696583a30eac95175e7eb6a8becde1-f8c68.jpg 1.5x,\n/static/luke-b4696583a30eac95175e7eb6a8becde1-d364e.jpg 2x,\n/static/luke-b4696583a30eac95175e7eb6a8becde1-e5a4b.jpg 3x"}}}}}}},pathContext:{slug:"hybrid-electron-application-deployment-in-the-enterprise",previous:{fields:{slug:"the-symphony-london-hackathon-2018"},frontmatter:{title:"The Symphony London Hackathon 2018"}},next:{fields:{slug:"automate-your-memory-profiling-now"},frontmatter:{title:"Automate your memory profiling now"}}}}}});
//# sourceMappingURL=path---hybrid-electron-application-deployment-in-the-enterprise-2e2e43c2843eaeed9acf.js.map